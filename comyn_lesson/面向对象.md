# 面向对象

面向对象是一种编程范式。

范式： 可以认为是一组方法论；

编程范式： 一组如何组织代码的方法论；


## 主流的编程范式：

    PP：面向过程； C语言为代表；
    IP：面向指令； 汇编为代表；更接近于机器；
    FP：函数式编程；要求：无副作用(相同的输入，总是能得到相同的输出)
    LP：面向逻辑的编程； 抽象成与、或、非三个逻辑状态；prolog为代表，在人工智能上用得比较多；
    OOP：面向对象的编程；
    AOP：面向方面的编程；在python中的体现为装饰器；SQL；


面向对象(OOP)： Object Oriented Programming；

## OOP的世界观：

* 世界是有对象组成的；
* 对象具有运动规律和内部状态；
* 对象之间可以相互作用；


以目前人类的认知来说，OOP是最接近真实世界的编程范式；

## 面向对象的特性：

* 唯一性：对象都是唯一的，不存在两个相同的对象，除非他们是同一个对象；
* 分类性：对象是可分类的；

程序是对世界的模拟；


## OOP的特征：

* 封装
* 继承 
* 多态


## Python的面向对象：

```python 
from collections import namedtuple

pet = namedtuple('Pet',['name','age'])

# 使用命名元组的目的： 为了组织数据；

lily = ('lily',3)

# 命名元组有什么优势：组织得更好，字段有名字；

Door = namedtuple('Door',['number','status'])

door = Door(1001,'closed')

print(door.number)

print(door.status)
# 能访问其属性，但是不能对其执行修改操作；因为元组是不可变对象；
```

```python 
class Door:
    def __init__(self,number,status):
        self.number = number
        self.status = status

door = Door(1001,'closed')
print(door.status)
print(door.number)

door.status = 'opening'
print(door.status)
```

## 定义一个类：

```python
class 类名:
    块
```

点号(.)用于访问对象的属性；

```python 
In [1]: class A:
   ...:     pass 
   ...: 

In [2]: a = A()   # 实例化对象；

In [3]: a
Out[3]: <__main__.A at 0x7fd65ef36630>
```

* 创建对象使用`类名(__init__函数中除第一个参数外的参数列表)`
* 创建对象的时候，实际执行了__init__函数；


```python 
In [13]: class D:
    ...:     def __init__(self):   # self引用的是实例变量，即实例化时的实例名称；
    ...:         print(id(self))
    ...:     
    ...:         

In [14]: d = D()
140558753338424

In [15]: id(d)
Out[15]: 140558753338424
```

* `__init__`函数不会创建对象；
* `__init__`函数初始化对象；
  - 首先创建对象；
  - 对象作为self参数传递给__init__函数；
  - 返回self 

```python 
In [17]: class Door:
    ...:     def __init__(self,number,status):  # 此处的self只是习惯用法，可以是其他符合规定的标识符；
    ...:         self.number = number
    ...:         self.status = status
    ...:     def open(self):   # 定义在类中的函数，被称为方法；
    ...:         self.status = 'opening'
    ...:         

In [18]: door = Door(1001,'closed')

In [19]: door.status
Out[19]: 'closed'

In [20]: Door.open(door)

In [21]: door.status
Out[21]: 'opening'

In [22]: door.status = 'closed'

In [23]: door.open()  # 当使用对象来调用的时候，第一个参数会自动的传入；

In [24]: door.status
Out[24]: 'opening'
```

方法定义在类中的好处：
* 保持一个纯净的命名空间；
* 直接使用对象来调用方法时，第一个参数(self)会自动的传入；


小结：
* 如何定义类；
* 如何创建对象；
* 如何定义方法；
* 方法调用； 


## 作用域：


```python 
In [26]: class E:   
    ...:     NAME = 'E'     # 类的直接下级作用域，叫做类变量；
    ...:     def __init__(self,name):
    ...:         self.name = name  # 关联到实例的变量，叫做实例变量；
    ...:         

In [27]: e = E('e')

In [28]: E.NAME
Out[28]: 'E'

In [29]: e.NAME
Out[29]: 'E'
# 类变量对类和实例都可见；


In [31]: e2 = E('e2')

In [32]: e2.NAME
Out[32]: 'E'

In [33]: e2.name
Out[33]: 'e2'

# 所有实例共享类变量；

In [34]: e2.NAME = 'E2'

In [35]: e2.NAME
Out[35]: 'E2'

In [36]: e.NAME
Out[36]: 'E'

# python可以动态的给实例和类增减属性：

In [37]: e.xxx = 3  

# 当给实例的类变量赋值时，相当于动态的给这个实例增加了一个属性，覆盖了类变量；

In [38]: e.xxx
Out[38]: 3

In [39]: e2.xxx
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-39-8ca2718f6555> in <module>()
----> 1 e2.xxx

AttributeError: 'E' object has no attribute 'xxx'

```

* Example：

```python
class Door:
    name = "Main door"   # 类变量，所有实例共享类变量；
    def __init__(self,number=None,status=None):
        if number == None:
            self.number = 1001   # 关联到实例的变量，叫做实例变量；
        else:
            self.number = number

        if status == None:
            if status == None:
                self.status = 'closed'
            else:
                self.status = status

door = Door(1001)
door2 = Door(1002)

# 类变量对类和实例都可见；
print(Door.name)   # Main door
print(door.name)   # Main door
print(door2.name)  # Main door

# python可以动态地给实例和类增减属性：
Door.person = 'kalaguiyin'
door.person = 'sslinux'

print(Door.person) # kalaguiyin
print(door.person) # sslinux

print(door2.person) # kalaguiyin   因为上面并没有直接给实例door2增加属性person,所以输出的是类变量：Door.person

# 当给实例的类变量赋值时，相当于动态的给这个实例增加了一个属性，覆盖了类变量；
print(Door.name)   # Main door
print(door.name)   # Main door
print(door2.name)  # Main door

door.name = "Second Door"

print(Door.name)   # Main door
print(door.name)   # Second Door
print(door2.name)  # Main door

door.xxx = 3
# print(Door.xxx)    # type object "Door" has no attribute 'xxx'
print(door.xxx)      # 3
# print(door2.xxx)     # 'Door' object has no attribute 'xxx'
```


* **赋值即创建**

```python
def outter():
    v = 3 
    def inner():
        v = 4
        
class E:
    NAME = "E"  # 类的直接下级作用域，叫做类变量；
    
    def __init__(self,name):
        self.name = name  # 关联到实例的变量，叫做实例变量；
```


## 属性的查找顺序：
* `__dict__`
* `__class__`
后续还有更多的查找顺序；

```python
In [38]: class E:
    ...:     NAME = "E"
    ...:     def __init__(self,name):
    ...:         self.name = name 
    ...:         

In [39]: e = E('e')

In [40]: e.NAME    # 相当于： e.__class__.NAME 
Out[40]: 'E'

In [41]: e.__class__.NAME
Out[41]: 'E'

In [42]: e.NAME = 'xxx'    # 相当于： e.__dict__['NAME']

In [43]: e.__dict__['NAME'] = 'X'

In [44]: e.NAME
Out[44]: 'X'

In [46]: e.__class__.NAME
Out[46]: 'E'

```


## 类装饰器

```python 
In [52]: def set_name(cls,name):
    ...:     cls.NAME = name 
    ...:     return cls
    ...: 

In [53]: class F:
    ...:     pass 
    ...: 

In [54]: F1 = set_name(F,'F')

In [55]: f1 = F1()

In [56]: F1.NAME
Out[56]: 'F'

In [57]: f1.NAME
Out[57]: 'F'

#########################################################
In [58]: def set_name(name):
    ...:     def warp(cls):
    ...:         cls.NAME = name 
    ...:         return cls 
    ...:     return warp
    ...: 

In [60]: @set_name('G')
    ...: class G:
    ...:     pass 
    ...: 

In [61]: G.NAME
Out[61]: 'G'


# 相当于：
# class G:
#     pass 
# 
# G = set_name('G')(G)

print(G.NAME)
```


```python
# 装饰器通常用于给类增加属性；

# 此处增加的是一个方法；增加方法有其他更好的实现方式；
def print_name(cls):
    def get_name(self):       # 整个get_name方法相当于写在class中的；
        return cls.__name__
    cls.__get_name__ = get_name
    return cls

@print_name
class H:    # 整个类H，被传递到print_name中作为cls；
    pass

h = H()
print(h.__get_name__())
```


* **方法都是类级的；** 


## 类方法/静态方法

方法的定义都是类级的，但是有的方法使用实例调用，有的方法使用类来调用；


```python 
In [54]: class I:
    ...:     def print(self):
    ...:         print('instance method')
    ...:         

In [55]: i = I()

In [56]: i.print() # 实例调用实例方法时，会自动传入self参数，self为实例本身； I.print(i)
instance method

In [57]: I.print()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-57-acb53bc932b5> in <module>()
----> 1 I.print()

TypeError: print() missing 1 required positional argument: 'self'

In [58]: I.print(i)
instance method

```
**实例方法只能由实例调用；**


## 类方法：

```python 
In [59]: class I:
    ...:     def print(self):
    ...:         print('instance method')
    ...:     @classmethod    # 内置的类装饰器，使用该装饰器后，调用I.class_print()时，传递的第一个参数不再是instance，而是class本身；
    ...:     def class_print(cls): # 这样的方法是类方法；
    ...:         print('class method')
    ...:         

In [60]: I.class_print()
class method

In [61]: class I:
    ...:     def print(self):
    ...:         print('instance method')
    ...:     @classmethod
    ...:     def class_print(cls):
    ...:         print(id(cls))
    ...:         print('class method')
    ...:         

In [62]: I.class_print()
30501992
class method

In [63]: i = I()

In [64]: i.class_print()  # 类方法可以被实例使用；并且被实例使用时，传入的第一个参数还是类；
30501992
class method
```

类方法与实例方法的区别：

    传入的第一个参数class的就是类方法；类方法无需实例化即可执行；所有实例共享；
    传入的第一个参数instance的就是实例方法；

```python 
In [65]: class I:
    ...:     def print(self):
    ...:         print('instance method')
    ...:     @classmethod
    ...:     def class_print(cls):
    ...:         print(id(cls))
    ...:         print('class method')
    ...:     @staticmethod  # 当一个方法，被staticmethod装饰的时候，不会自动传递第一个参数，这样的方法叫静态方法；
    ...:     def static_print():
    ...:         print('static method')
    ...:         

In [66]: i = I()

In [67]: i.static_print()
static method
```

```python 
# 方法的定义都是类级的，但是有的方法使用实例调用，有的方法使用类来调用；

class I:
    def instance_print(self):
        print('instance method')

    @classmethod # 内置类装饰器，当一个方法被classmethod装饰的时候，调用该方法时，传递的第一个参数不再是instance，而是class本身；
    def class_print(cls):
        print(id(cls))
        print('class method')

    @staticmethod   # 当一个方法，被staticmethod装饰的时候，不会自动传入第一个参数，这样的方法叫静态方法；
    def static_print():
        print('static method')

    def xxx_print():    # 不加任何装饰器，也不传递self，实例不能调用； 只是一个定义在类作用域下的函数；
        print("this is a function")


i = I()

# 调用实例方法：
i.instance_print()    # 实例调用实例方法的时候，会自动传入self参数，self为实例本身；

# 调用类方法：
I.class_print()   # 37893592   class method
print(id(I))      # 37893592

i.class_print()   # 类方法可以被实例使用，并且被实例使用时，传入的第一个参数还是类；
                  # 类方法无需实例化就可以执行；

# 调用静态方法：
i.static_print()


# 调用类中定义的普通函数：
I.xxx_print()
``` 

---

## 访问控制

```python 
class Door:
    def __init__(self,number,status):  # 此处的self只是习惯用法，可以是其他符合规定的标识符；
        self.number = number
        self.status = status

    def open(self):   # 定义在类中的函数，被称为方法；
        self.status = 'opening'

    def close(self):
        self.status = 'closed'

door = Door(1001,'closed')
print(door.status)
door.status = 'fuck it'   # 我们希望某个属性的取值只能是规定的几个，不能自定义；
print(door.status)
```

```python 
class Door:
    def __init__(self,number,status):  # 此处的self只是习惯用法，可以是其他符合规定的标识符；
        self.number = number
        self.__status = status  # 双下划线开始，非双下划线结尾的都是私有的，在类外部无法访问；

    def open(self):   # 定义在类中的函数，被称为方法；
        self.__status = 'opening'

    def close(self):
        self.__status = 'closed'

    def status(self):
        return self.__status
    
    def __set_number(self,number):   # 双下划线开始，非双下划线结尾的方法也是私有方法；
        self.number = number

door = Door(1001,'closed')
door.__status = 'fuck it'  # 给对象创建了新的属性，并没有修改__status。
print(door.__status)
print(door.status())
```

**所有双下划线开始，非双下划线结尾的成员，都是私有成员**

## python访问私有成员：

    _类名 + 带双下划线的属性

**python的私有成员是通过改名实现的；**

```python 
In [71]: class Door:
    ...:     def __init__(self,number,status):  # 此处的self只是习惯用法，可以是其他符合规定的标识符；
    ...:         self.number = number
    ...:         self.__status = status
    ...: 
    ...:     def open(self):   # 定义在类中的函数，被称为方法；
    ...:         self.__status = 'opening'
    ...: 
    ...:     def close(self):
    ...:         self.__status = 'closed'
    ...: 
    ...:     def status(self):
    ...:         return self.__status
    ...: 
    ...:     def __set_number(self,number):   # 双下划线开始，非双下划线结尾的方法也是私有方法；
    ...:         self.number = number
    ...:         

In [72]: door = Door(1001,'closed')

In [73]: door.__status
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-73-d55234f04e7f> in <module>()
----> 1 door.__status

AttributeError: 'Door' object has no attribute '__status'

In [75]: door._Door__status #  _类名 + 带双下划线的属性,访问私有成员；
                            # 单下划线(_) + 类名. + 带双下划线的属性名，访问私有成员；
Out[75]: 'closed'

In [76]: door._Door__status = 'opening'

In [77]: door.status()
Out[77]: 'opening'

In [78]: door._Door__status = 'fuck it'

In [79]: door.status()
Out[79]: 'fuck it'
```
### 严格的说，Python里没有真正的私有成员；

**除非真的有必要，并且清楚明白地知道会有什么后果，否则不要用这个黑魔法(使用改名后的属性名：_Class.__attribute)。** 

**90%的程序员，有生之年用不到。对封装性是一种破坏。**

猴子补丁：

    gevent；  需要使用上述访问私有成员的方法；

### 以单下划线(_)开头的成员，是一种习惯用法，标记此成员为私有，但是解释器并不做任何处理。只是约定俗成，不强制要求。
```python 
In [80]: class J:
    ...:     def __init__(self):
    ...:         self._a = 3
    ...:         

In [81]: j = J()

In [82]: j._a
Out[82]: 3

In [83]: j._a = 4

In [84]: j._a
Out[84]: 4

In [85]: j.__dict__
Out[85]: {'_a': 4}
```

## property装饰器会把一个仅有self参数的函数，变成一个属性；属性的值为方法的返回值；

```python 
In [73]: class Door:
    ...:     def __init__(self,number,status):
    ...:         self.number = number
    ...:         self.__status = status
    ...: 
    ...:     def open(self):
    ...:         self.__status = 'opening'
    ...: 
    ...:     def close(self):
    ...:         self.__status = 'closed'

    ...:     @property          # property装饰器会把一个仅有self参数的函数，变成一个属性；属性的值为方法的返回值；
    ...:     def status(self):
    ...:         return self.__status
    ...:         

In [74]: door = Door(1001,'closed')

In [75]: door.status
Out[75]: 'closed'

In [76]: door.status()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-76-76c604e52a9b> in <module>()
----> 1 door.status()

TypeError: 'str' object is not callable

```

```python
In [77]: class Door:
    ...:     def __init__(self,number,status):
    ...:         self.__number = number
    ...:         self.__status = status
    ...: 
    ...:     def open(self):
    ...:         self.__status = 'opening'
    ...: 
    ...:     def close(self):
    ...:         self.__status = 'closed'
    ...:     @property
    ...:     def status(self):
    ...:         return self.__status
    ...:     def __set_nubmer(self,number):
    ...:         self.__number = number 
    ...:     def set_number(self,number):
    ...:         if isinstance(number,int) and number > 0 and number < 10000:
    ...:             self.__number = number
    ...:     def number(self):
    ...:         return self.__number
    ...:     
In [79]: door = Door(1001,'closed')

In [81]: door.status
Out[81]: 'closed'

In [82]: door.number()
Out[82]: 1001

In [83]: door.set_number(5001)

In [85]: door.number()
Out[85]: 5001

In [86]: door.set_number('abcd1234')

In [87]: door.number()
Out[87]: 5001

```

```python 
In [88]: class Door:
    ...:     def __init__(self,number,status):
    ...:         self.__number = number
    ...:         self.__status = status
    ...: 
    ...:     def open(self):
    ...:         self.__status = 'opening'
    ...: 
    ...:     def close(self):
    ...:         self.__status = 'closed'
    ...:     @property    
    ...:     def status(self):
    ...:         return self.__status
    ...:     def __set_nubmer(self,number):
    ...:         self.__number = number 

    ...:     @property    # property装饰器会把一个仅有self参数的函数，变成一个属性；属性的值为方法的返回值；
    ...:     def number(self):
    ...:         return self.__number
    ...:     
            # property setter 这个装饰器，可以把一个方法转化为对此属性赋值，但此方法有一定要求：
            # 1、必须和被property装饰的属性同名；
            # 2、必须接受两个参数：self和value，value为所赋的值
            # 3、前后顺序：property setter所装饰的方法在被property装饰的属性之后；
    ...:     @number.setter    
    ...:     def number(self,number):
    ...:         if isinstance(number,int) and number > 0 and number < 10000:
    ...:             self.__number = number
    ...:         

In [89]: door = Door(1001,'closed')

In [90]: door.number
Out[90]: 1001

In [91]: door.number = 5001

In [92]: door.number
Out[92]: 5001

In [93]: door.number = 'abcd1234'   # 对使用property setter装饰器的属性赋值(赋不符合要求的值，不生效)

In [94]: door.number
Out[94]: 5001

```

```python 
In [96]: class Door:
    ...:     def __init__(self,number,status):
    ...:         self.__number = number
    ...:         self.__status = status
    ...:         self.xxx = 5
    ...: 
    ...:     def open(self):
    ...:         self.__status = 'opening'
    ...: 
    ...:     def close(self):
    ...:         self.__status = 'closed'
    ...:     @property
    ...:     def status(self):
    ...:         return self.__status
    ...:     def __set_nubmer(self,number):
    ...:         self.__number = number 
    ...:     @property
    ...:     def number(self):
    ...:         return self.__number
    ...:     
    ...:     @number.setter    
    ...:     def number(self,number):
    ...:         if isinstance(number,int) and number > 0 and number < 10000:
    ...:             self.__number = number

    ...:     @number.deleter   # 动态删除经过property装饰过的方法时，执行该方法；
    ...:     def number(self):
    ...:         print("can't remove number property")
    ...:             

In [97]: door = Door(1001,'close')

In [98]: door.xxx   # 临时添加的无关紧要的属性；
Out[98]: 5

In [99]: del door.xxx   # 动态删除属性；

In [100]: door.xxx
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-100-045038705f09> in <module>()
----> 1 door.xxx

AttributeError: 'Door' object has no attribute 'xxx'

In [101]: del door.open    # 无法删除方法；
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-101-10518c49374f> in <module>()
----> 1 del door.open

AttributeError: open

In [102]: del door.number       # 动态删除经过property装饰的方法时，执行使用property deleter装饰的方法；
can't remove number property

上述的三个经过property装饰的方法还可以使用以下的方式定义：
number = property(lambda self: self.__number,lambda self,value:self.__number = value,lambda self: print("can't remove number property"))
```

## 以上内容为——封装；
私有属性也是封装的一种；
property使得封装更为容易；



## 类的继承：

```python 
# 继承的基本写法：
class Base:
    def base_print(self):
        print('base')

class A(Base):  # 在类名后加括号，括号中是继承(类的)列表； 括号中的称为父类，或者基类，或者超类；
    def a_print(self):
        print('a')

a = A()

a.a_print()     # 子类的方法； 
a.base_print()  # 继承自Base类的方法；
```

**继承的一个明显的好处就是可以获取父类的属性和方法。代码复用**

```python 
class Base:
    PUBLIC_CLASS_VAR = 'PUBLIC_CLASS_VAR'     
    _PRIVATE_CLASS_VAR = 'PRIVATE_CLASS_VAR' 

    def __init__(self):
        self.public_instance_var = 'public_instance_var'
        self.__private_instance_var = 'private_instance_var'

    @classmethod
    def public_class_method(cls):
        return 'public_class_method'

    @classmethod
    def __private_class_method(cls):
        return 'private_class_method'

    @staticmethod
    def public_static_method():
        return 'public static method'

    @staticmethod
    def __private_static_method():
        return 'private static method'

    def public_instance_method(self):
        return 'public_instance_method'

    def __private_instance_method(self):
        return 'private_instance_method'

class Sub(Base):
    def print(self):
        print(self.public_static_method())

sub.__dict__
```

验证：
* 凡是公有的(属性和方法)都能继承；
* 凡是私有的(属性和方法)都不能继承；因为私有的名称转换了。
* 原来是什么，继承过来还是什么：原来是类的属性和方法，继承过来还是类的，原来是实例的，继承过来还是实例的；



---


## 方法重写：

```python 
In [90]: class Base:
    ...:     def print(self):
    ...:         print('Base.print')
    ...:         

In [91]: class Sub(Base):
    ...:     def print(self):  ## 当子类和父类有同名成员的时候，子类的成员会覆盖父类的同名成员；
                               ## 但是结果是无法调用父类的方法；
    ...:         print('Sub.print')
    ...:         

In [92]: sub = Sub()

In [93]: sub.print()
Sub.print
```

```python 
class Base:
    def print(self):
        print('Base.print')

class Sub(Base):
    def foo(self):
        self.print()  # 调用父类的print方法；

sub = Sub()

sub.foo()
```

```python
class Base:
    def print(self):
        print('Base.print')

class Sub(Base):
    def print(self):        # 已经将父类的print方法重写了；
        print('Sub print')

    def foo(self):
        self.print()  # 此时调用的是子类的方法；

sub = Sub()

sub.foo()
```


```python 
class Base:
    def print(self):
        print('Base.print')
        

class Sub(Base):
    def print(self):
        print('Sub print')

    def foo(self):
        # self.print()  # 此时调用的是子类的方法；
        super().print() # 调用的是父类的print方法；
        super(Sub,self).print() # 和前一行是一样的；

        # super(Sub).print()
        # super(Base,Sub).print()

sub = Sub()

sub.foo()
```

```python 
class Base:
    def print(self):
        print('Base.print')

    @classmethod
    def cls_print(cls):
        print("Base.cls_print")


class Sub(Base):
    def print(self):
        print('Sub print')

    @classmethod
    def cls_print(cls):
        print("Sub.cls_print")

    def foo(self):
        # self.print()  # 此时调用的是子类的方法；
        super().print() # 调用的是父类的print方法；
        super(Sub,self).print() # 和前一行是一样的；
        # super(Sub).print()
        # super(Base,Sub).print()

    @classmethod
    def cls_foo(cls):
        cls.cls_print()
        Base.cls_print()
        super().cls_print()

sub = Sub()

sub.cls_foo()
```

```python
class SubSub(Sub):
    def print(self):
        print('SubSub.print')

    def foo(self):
        # 调用Base的print
        super(Sub,self).print()

SubSub().foo()
```

```python 
class SubSub(Sub):
    def print(self):
        print('SubSub.print')

    @classmethod
    def cls_print(cls):
        print('SubSub.cls_print')

    def foo(self):
        # 调用Base的print
        super(Sub,self).print()  # 代理TYPE的父类的方法，并且使用obj绑定；
                                # 第一个参数 指定调用谁的直接父类；
                                # 第二个参数 指定当调用时，传递什么作为方法的第一个参数； 

    @classmethod
    def cls_foo(cls):
        # 调用Base的cls_print方法；
        # Base.cls_print()
        super(Sub,cls).cls_print()

SubSub().cls_foo()
```


```python 
class Base:
    def print(self):
        print("Base.print")

    @classmethod
    def cls_print(cls):
        print('Base.cls_print')


class Sub(Base):
    def print(self):
        print('Sub.print')

    @classmethod
    def cls_print(cls):
        print("Sub.cls_print")

    def foo(self):
        # self.print()   # 调用父类的print方法；
        super().print()
        # super(Base,Sub).print()

    @classmethod
    def cls_foo(cls):
        # cls.cls_print()
        # Base.cls_print()
        super().cls_print()
        # super(Base,cls).cls_print()    # wrong;

class SubSub(Sub):
    def print(self):
        print('SubSub.print')

    @classmethod
    def cls_print(cls):
        print("SubSub.cls_print")


    def foo(self):
        # 调用Base的print；
        super(Sub,self).print()  # 代理TYPE的父类的方法，并且使用obj绑定；
        pass

    @classmethod
    def cls_foo(cls):
        Base.cls_print()
        super(Sub,cls).cls_print()


SubSub().foo()
print("*"*30)
SubSub().cls_foo()

```


**super并不妨碍私有属性的保护。** 


[Python开发社区](http://www.ctolib.com)

---

### 当父类含有一个带参数的初始化方法的时候，子类一定需要一个初始化方法，并在初始化方法中调用父类的初始化方法；


```python 
class Base:
    def __init__(self,a,b):
        self.__a = a
        self.__b = b

    def sum(self):
        return self.__a + self.__b

class Sub(Base):
    def __init__(self,a,b,c):
        self.c = c
        # self.a = a
        # self.b = b
        super().__init__(a,b)

sub = Sub(1,2,3)
print(sub.sum())
```
---


```python 
class Base:
    def __init__(self):
        self.a = 3

class Sub(Base):
    def __init__(self):
        self.a = 5

    def print(self):
        print(self.a)
        print(super().a)   # 获取父类的实例变量：  这是一个伪命题；不存在这样的问题；


Sub().print()
```


```python
class Base:
    NAME = "BASE"

class Sub(Base):
    NAME = 'SUB'

    def print(self):
        print(self.NAME)
        print(super().NAME)
        print(super(Sub,Sub).NAME)    # 获取父类的类变量；
        print(Base.NAME)

Sub().print()
```

## **super对象只能获取类的属性**


## 多继承：

如果不显式说明，则类继承自object类；

```python 
In [6]: class A(object):
   ...:     pass 
   ...: 

In [7]: class A():
   ...:     pass
   ...: 

In [8]: class A:
   ...:     pass
   ...: 
```

```python
In [9]: class Base:
   ...:     pass 
   ...: 

In [10]: class Sub(Base):
    ...:     pass 
    ...: 

In [11]: class Sub(Base,object):  # 多继承，在继承列表里存在多个类的时候表示多继承；
    ...:     pass 
    ...: 

In [12]: class Base2:
    ...:     pass 
    ...: 

In [13]: class Sub2(Base,Base2):
    ...:     pass 
    ...: 
```
多继承会把继承列表里的所有公有成员都继承过来；


同名的时候怎么办？



## 多继承


```python
class A():
    pass 
```

```python
class A:
    pass
```

```python
class A(object):
    pass
```

上面三个类在py3中是完全等价的，所有未声明类的都继承自object类；


```python
In [1]: class Base:
   ...:     pass
   ...: 

In [2]: class Sub(Base):
   ...:     pass
   ...: 

In [3]: class Sub(Base,object):
   ...:     pass
   ...: 

In [4]: class Base2:
   ...:     pass
   ...: 

In [5]: class Sub2(Base,Base2):   # 多继承，在继承列表里存在多个类的时候表示多继承； 
   ...:     pass
   ...: 
```


多继承会把继承列表里的所有公有成员都继承过来；

方法或属性同名的时候怎么办？

```python 
In [6]: class A:
   ...:     def method(self):
   ...:         print('method of A')
   ...:         

In [7]: class B:
   ...:     def method(self):
   ...:         print('method of B')
   ...:         

In [8]: class C(A,B):
   ...:     pass
   ...: 

In [9]: c = C()

In [10]: c.method()   # 类C继承时的顺序为A,B,所以类A、B中存在同名方法时，使用A中的；
method of A

In [11]: class D(B,A):
    ...:     pass
    ...: 

In [12]: d = D()

In [13]: d.method()  # 类D继承时的顺序为B、A，所以使用类B中的method方法；
method of B
```

## 顺序查找


```python
In [14]: class E(A):
    ...:     def method(self):
    ...:         print("method of E")
    ...:         

In [15]: class F(A,E):   # 类E继承自A，我个人觉得晚辈应该冲在前面，长辈应该在后面指挥。
    ...:     pass
    ...: 
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-15-6a7ec71d02f4> in <module>()
----> 1 class F(A,E):
      2     pass

TypeError: Cannot create a consistent method resolution
order (MRO) for bases E, A

In [16]: class G(E,A):
    ...:     pass
    ...: 

In [17]: g = G()

In [18]: g.method
Out[18]: <bound method E.method of <__main__.G object at 0x7fc3395965f8>>

In [19]: g.method()
method of E
```

多重继承会引发二义性。
python中一切皆引用，这使得它不会像C++ 一样使用 虚基类 处理基类对象重复的问题，但是如果父类存在同名函数的时候还是会产生二义性。

python中处理这种问题的方法就是MRO。

## MRO: 方法查找顺序

MRO： Method Resolution Order：方法解析顺序；

* 本地优先：自己定义或重写的方法优先；然后按照继承列表，从左到右查找；
* 单调性：所有子类，也要满足查找顺序；


```python
In [2]: class A:
   ...:     def method(self):
   ...:         print("method of A")
   ...:         

In [3]: class B(A):
   ...:     def method(self):
   ...:         print("method of B")
   ...:         

In [4]: class C(A,B):    # 定义不成功，因为B继承自A，B是晚辈，A是长辈；
   ...:     def method(self):
   ...:         print("method of C")
   ...:         
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-4-a8bb2e1a8ce0> in <module>()
----> 1 class C(A,B):
      2     def method(self):
      3         print("method of C")
      4 

TypeError: Cannot create a consistent method resolution
order (MRO) for bases B, A

In [5]: class D(B,A):
   ...:     def method(self):
   ...:         print("method of D")
   ...:         

In [6]: A.__mro__
Out[6]: (__main__.A, object)

In [7]: B.__mro__
Out[7]: (__main__.B, __main__.A, object)

In [8]: D.__mro__
Out[8]: (__main__.D, __main__.B, __main__.A, object)

In [9]: class E(B):
   ...:     pass
   ...: 

In [10]: E.__mro__
Out[10]: (__main__.E, __main__.B, __main__.A, object)
```

(F,A,E,object)   # 不满足E的单调性；

两种MRO的方法
1. 如果是经典类MRO为DFS（深度优先搜索（子节点顺序：从左到右））。
2. 如果是新式类MRO为BFS（广度优先搜索（子节点顺序：从左到右））。

```python
In [1]: class D:
   ...:     def method():
   ...:         print("method of D.")
   ...:         

In [2]: class B(D):
   ...:     pass 
   ...: 

In [3]: class E:
   ...:     pass
   ...: 

In [4]: class C(E):
   ...:     def method():
   ...:         print("method of C")
   ...:         

In [5]: class A(B,C):
   ...:     pass
   ...: 

In [6]: a = A()

In [10]: A.__mro__
Out[10]: (__main__.A, __main__.B, __main__.D, __main__.C, __main__.E, object)
# 查找先从B和B的父类开始查找的顺序，我们称之为单调性。
```

### C3算法

C3算法解决了单调性问题，和只能继承无法重写的问题。

python通过C3算法来确定是否满足mro的两个原则；

```python 
class B(O) -> [B,O]

class B(A1,A2,....,An) -> [B] + merge(mro(A1),mro(A2),...,mro(An),[A1,A2,...An,O])
```

merge： vt.合并；使合并；吞没；vi.合并；融合；

merge的步骤

* 遍历列表；
* 看第一个列表的首元素：
  - 它在其他列表里也是首元素
  - 它在其他列表里不存在；
* 满足以上两种情况，移除，合并到MRO；
* 不满足，抛出异常；


```
mro(G) -> [G] + merge(mro(E),mro(A))
       -> [G] + merge([E,A,O],[A,O],[E,A,O])
       -> [G,E] + merge([A,O],[A,O],[A,O])
       -> [G,E,A] + merge([O],[O],[O])
       -> [G,E,A,O]
```


```
mro(F) -> [F] + merge(mro(A),mro(E),[A,E,O])
       -> [F] + merge([A,O],[E,A,O]，[A,E,O])
       -> raise Exception
```

当一个类定义的时候，解释器会执行C3算法来确定mro，如果C3算法抛出异常，此类不能定义；

应该尽量避免多继承


```python
class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(B,A):
    pass

class E(C,A):
    pass

class F(E):
    pass 

class G(F,D):
    pass
```

多继承会对程序员的心智负担造成非常大的压力；

python是解释执行的，一段代码只有执行到的时候，才知道有没有错。

多继承是一剂毒药，有的语言(如:java)明确禁止多继承；

类装饰器：

    设置一些类变量；
    
    可以给类增加一些方法；  # 但是不够优雅；

## Mixin

如何以AOP(面向方面)的方式给类增加方法？

       Document

    Word   Excel

printableWord printableExcel

PrintToPrinterWord  



```python
def print_to_printer(cls):
    def print(self):
        pass 
    cls.print_to_printer = print
    return cls 
```

如果一个类，不能动态地增加成员的时候，类装饰器的方法行不通；

### 使用类装饰器方式：

```python
In [44]: class Document:
    ...:     def __init__(self,content):
    ...:         self.content = content
    ...:         

In [45]: class Word(Document):
    ...:     def __init__(self,content):
    ...:         super().__init__('word:{}'.format(content))  # 将'word:content'一起传递给类Document的__init__函数；
    ...:         

In [46]: class Excel(Document):
    ...:     def __init__(self,content):
    ...:         super().__init__('excel:{}'.format(content))
    ...:         

In [47]: def printable(cls):         # 装饰器： 
    ...:     def _print(self):
    ...:         print(self.content)
    ...:     cls.print = _print
    ...:     return cls
    ...: 

In [48]: @printable
    ...: class PrintableWord(Word):
    ...:     def __init__(self,content):     
    ...:         super().__init__(content)      # 将content参数传递给类Word的__init__函数；
    ...:         

In [49]: pw = PrintableWord('abc')

In [50]: pw.print()
word:abc
```

```python
In [52]: def print_to_monitor(cls):
    ...:     def _print(self):
    ...:         print('Monitor:P: {}'.format(self.content))
    ...:     cls.print = _print
    ...:     return cls
    ...: 

In [53]: @print_to_monitor
    ...: class PrintMonitorWord(Word):
    ...:     def __init__(self,content):
    ...:         super().__init__(content)
    ...:         

In [54]: pmw = PrintMonitorWord('abc')

In [55]: pmw.print()
Monitor:P: word:abc
```


---

### 使用mixin方式：

```python
In [56]: class PrintableMixin:
    ...:     def print(self):
    ...:         result = 'P: {}'.format(self.content)
    ...:         print(result)
    ...:         return result
    ...:     

In [57]: class PrintableWord(PrintableMixin,Word):
    ...:     def __init__(self,content):
    ...:         super().__init__(content)
    ...:         

In [58]: pw = PrintableWord('abc')

In [59]: pw.print()
P: word:abc
Out[59]: 'P: word:abc'
```


```python
In [60]: class PrintToMonitorMixin(PrintableMixin):
    ...:     def print(self):
    ...:         print("Monitor:{}".format(super().print()))
    ...:         

In [61]: class PrintToMonitorWord(PrintToMonitorMixin,Word):
    ...:     def __init__(self,content):
    ...:         super().__init__(content)
    ...:         

In [62]: pw = PrintToMonitorWord('abc')

In [63]: pw.print()
P: word:abc
Monitor:P: word:abc
```

Mixin其实也是一种组合的方式；

通常来说，组合优于继承；

Mixin 类的限制：
* Mixin 类不应该有初始化方法；
* Mixin类通常不能独立工作；
* Mixin类的祖先也应该是Mixin类；

通常情况下，Mixin类总在继承列表的第一位；

类： 无法修改

扩展一些方法

扩展的方法，写到一个Mixin类里；

写一个类，继承Mixin和无法修改的类；

新的类就具有了要扩展的方法了。

Mixin是依靠多继承来实现的，除了使用Mixin的时候，尽量避免使用多继承；

---
---

## 魔术方法/专有方法


```python
In [1]: class A:
   ...:     pass
   ...: 

In [2]: dir(A)   # 用内置函数dir()可以得到类A的所有公有成员；
Out[2]: 
['__class__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__le__',
 '__lt__',
 '__module__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__']

```

### 属性：
```python 
In [4]: dir(a)   # 调用的是a.__dir__()
Out[4]: 
['__class__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__le__',
 '__lt__',
 '__module__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__']

In [5]: a.__dir__()
```


### 类属性：


```python
In [6]: A.__name__    # 类名；
Out[6]: 'A'
```

```python
In [7]: A.__module__  # 模块； 因为是在ipython中，所以都为__main__；
Out[7]: '__main__'
```

```python
In [8]: A.__doc__     # 文档字符串
```


```python
In [9]: A.__class__   # 类型，自定义类的类型都是type；
Out[9]: type
```

### 实例属性：


```python
In [10]: a.__name__
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-10-f972462453b7> in <module>()
----> 1 a.__name__

AttributeError: 'A' object has no attribute '__name__'
```

```python
In [11]: a.__doc__
```


```python
In [12]: a.__module__
Out[12]: '__main__'
```

```python
In [13]: a.__class__
Out[13]: __main__.A

In [14]: lst = list()

In [15]: lst.__class__
Out[15]: list
```




```python
In [16]: a.__class__.__name__   # 得到实例的类名；
Out[16]: 'A'
```

```python
In [17]: a.__dict__   # 实例的所有属性，都保存在__dict__里
Out[17]: {}

In [19]: a.xxx = 3

In [20]: a.__dict__
Out[20]: {'xxx': 3}

In [21]: a.__dict__['xxx'] = 5   # a.__dict__是一个字典，可以通过对其键进行操作；

In [22]: a.xxx
Out[22]: 5

In [23]: a.__dict__
Out[23]: {'xxx': 5}

```

```python
In [24]: a.__dict__[set(1,2,3)] = 5   # set(1,2,3) 对于字典来说是可以做key的，但对于实例不行；
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-24-f025063ed91d> in <module>()
----> 1 a.__dict__[set(1,2,3)] = 5

TypeError: set expected at most 1 arguments, got 3
```



```python
In [25]: a.__dict__
Out[25]: {'xxx': 5}

In [26]: a.__dict__['x y z'] = 10   # 作为字典的键，最好遵守标识符的规则；

In [27]: a
Out[27]: <__main__.A at 0x7f14271b9c50>

In [28]: a.__dict__
Out[28]: {'x y z': 10, 'xxx': 5}

In [29]: a.__dict__['x y z']
Out[29]: 10

In [30]: a.x y z   # 使用点号无法引用包含空格的键；
  File "<ipython-input-30-2a5b2876ab06>", line 1
    a.x y z
        ^
SyntaxError: invalid syntax
```

```python
In [32]: a.__dir__()  # 得到实例的所有成员，包括方法和属性，dir()函数调用的是__dir__()
Out[32]: 
['__dir__',
 '__ge__',
 '__doc__',
 '__subclasshook__',
 '__module__',
 '__repr__',
 '__ne__',
 '__dict__',
 '__format__',
 '__lt__',
 '__reduce_ex__',
 'xxx',
 'x y z',
 '__str__',
 '__sizeof__',
 '__new__',
 '__eq__',
 '__init__',
 '__class__',
 '__weakref__',
 '__delattr__',
 '__reduce__',
 '__getattribute__',
 '__le__',
 '__hash__',
 '__gt__',
 '__setattr__']

 # dir(a)的结果是：   a.__dir__()排序后的结果；
 In [33]: dir(a) == a.__dir__()
Out[33]: False

In [34]: dir(a) == sorted(a.__dir__())
Out[34]: True

In [35]: dir(a) == a.__dir__().sort()
Out[35]: False


In [37]: dir(a) == a.__dir__().sort()
Out[37]: False

In [38]: dir(a).sort() == a.__dir__().sort()
Out[38]: True
```


### 分类：

* 创建/销毁
* 运算符重载
* hash
* bool 
* 可视化
* 反射
* 上下文管理
* 大小
* 描述器
* 杂项

---


### 运算符重载


```python
In [39]: class Point:
    ...:     def __init__(self,x,y):
    ...:         self.x = x
    ...:         self.y = y
    ...:     def add(self,other):
    ...:         return Point(self.x + other.x,self.y + other.y)
    ...:     

In [40]: a = Point(0,0)

In [41]: b = Point(3,5)

In [42]: c = a.add(b)  # 可以通过实例方法进行运算；

In [43]: c.x
Out[43]: 3

In [44]: c.y
Out[44]: 5

In [45]: a + b   # 不支持使用加号运算两个Point实例；
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-45-f96fb8f649b6> in <module>()
----> 1 a + b

TypeError: unsupported operand type(s) for +: 'Point' and 'Point'
```


### 加号(+)重载：

```python
In [46]: class Point:
    ...:     def __init__(self,x,y):
    ...:         self.x = x
    ...:         self.y = y
    ...:     def add(self,other):
    ...:         return Point(self.x + other.x,self.y + other.y)
    ...:     def __add__(self,other):   # 重载加法运算；
    ...:         return Point(self.x + other.x,self.y + other.y)
    ...:     

In [47]: a = Point(0,0)

In [48]: b = Point(3,5)

In [49]: c = a.add(b)

In [51]: print(c.x,c.y)
3 5

In [52]: d = a + b

In [53]: print(d.x,d.y)
3 5
```



```python
In [54]: class Point:
    ...:     def __init__(self,x,y):
    ...:         self.x = x
    ...:         self.y = y
    ...:     def add(self,other):
    ...:         return Point(self.x + other.x,self.y + other.y)
    ...:     def __add__(self,other):  # 调用add方法即可，不用重写一遍；
    ...:         return self.add(other)
    ...:         
    ...:     

In [55]: a = Point(0,0)

In [56]: b = Point(3,5)

In [57]: c = a + b 

In [58]: print(c.x,c.y)
3 5

In [60]: c += Point(4,6)    # 可以使用自增运算符；

In [61]: print(c.x,c.y)
7 11
```



**算数运算**

通过int的帮助信息，可以找到大多数的算数运算符重载方法；

```python 
## 加、减号运算符重载：
In [70]: class Point:
    ...:     def __init__(self,x,y):
    ...:         self.x = x
    ...:         self.y = y
    ...: 
    ...:     def add(self,other):
    ...:         return Point(self.x + other.x,self.y + other.y)
    ...: 
    ...:     def __add__(self,other):
    ...:         return self.add(other)
    ...: 
    ...:     def sub(self,other):
    ...:         return Point(self.x - other.x,self.y - other.y)
    ...: 
    ...:     def __sub__(self, other):
    ...:         return self.sub(other)
    ...:     

In [72]: a = Point(0,0)
    ...: b = Point(3,5)
    ...: c = a + b
    ...: d = a - b
    ...: 

In [73]: print(c.x,c.y)
3 5

In [74]: print(d.x,d.y)
-3 -5

In [75]: c += Point(-3,-4)

In [76]: print(c.x,c.y)
0 1

In [78]: d -= Point(-5,-8)

In [79]: print(d.x,d.y)
2 3

```

### 位运算
### 比较运算
### 成员运算

身份运算和赋值运算，无法重载

不要过度的使用运算符重载


---

# 小结：

## 哲学问题

## 类的定义 
* 类装饰器 


## 类的实例化
* self参数；

## 作用域：
* 类变量：
  - 所有实例共享；
  - 赋值即创建； 


根据首参来决定：
* 类方法 
* 静态方法 
* 实例方法 

## 访问控制 
* 私有成员 
* property


## 继承 
* 基本语法 
* 访问控制 
* 方法重写 
  - super方法
  - super对象 

## 多态： 
* 方法重写 
* 运算符重载  



